package gm22_9.segundaEntregaFIS;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Hashtable;
import java.util.Iterator;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : gm22_9_califyMe
//  @ File Name : PersistenciaUsr.java
//  @ Date : 28/05/2020
//
//



/**
 * Clase Singleton que gestiona la persistencia de los usuarios
 *
 */
public class PersistenciaUsr implements IPersistenciaUsr {

    private static PersistenciaUsr instanciaUnica;
    private IConectorBBDD conex;
    
    /**
     * Constructor privado de la clase Singleton
     */
    private PersistenciaUsr() {
    }
    
    /**
     * Devuelve instancia unica
     * @return
     */
    public static PersistenciaUsr getInstance() {
    	if (instanciaUnica == null) {
    		instanciaUnica = new PersistenciaUsr();
    	}
    	return instanciaUnica;
    }
    
    @Override
    public void setConex(IConectorBBDD conex) {
		this.conex = conex;
	}
    
    @Override
    public void create(Usuario usr) {
    	//Como para esta implementacion solo se pueden crear Alumnos, se asumira
    	//que todos los nuevos Usuarios son Alumnos y se escribiran en esa tabla.
    	Alumno tmpAl = (Alumno) usr;
    	//Insercion del Usuario
    	String sql = "INSERT INTO Alumno(correoETSISI, dni, nombreAl, apellidos, matricula, passw) "
    			+ String.format("VALUES ('%s', '%s', '%s', '%s', '%s', '%s');",
    					tmpAl.getCorreo(), tmpAl.getDNI(), tmpAl.getNombreUsuario(), tmpAl.getApellidos(),
    					tmpAl.getMatricula(), tmpAl.getPassword());
    	conex.ejecutarOperacion(sql);
    	
    	//Insercion de asignaturas matriculadas
    	Iterator<String> it = tmpAl.getAsignaturasCursadas().iterator();
    	while (it.hasNext()) {
    		sql = String.format("INSERT INTO Cursa(correoAlumno, asignatura) VALUES ('%s', '%s');",
    				tmpAl.getCorreo(), it.next());
    	}
    }
    
    @Override
    public Usuario read(String correo) {
    	Usuario result = null;
    	boolean esAlumno = esUsuarioAlumno(correo);
    	String sql = null;
    	if (esAlumno) {
    		sql = "SELECT dni, nombreAl, apellidos, matricula, passw FROM Alumno WHERE "
    				+String.format("correoETSISI = '%s';", correo);
    	} else {
    		//es profesor
    		sql = "SELECT dni, nombreProf, apellidos, passw, codEmpleado, codDepartamento FROM Profesor WHERE "
    				+String.format("correoETSISI = '%s';", correo);
    	}
    	
    	ResultSet rs = conex.ejecutarBusqueda(sql);
    	if (rs != null) {
			try {
				if (rs.next()) { //Es if y no while porque al buscar por la PK solo puede devolver un resultado o ninguno
					if (esAlumno) {
						result = new Alumno(rs.getString("dni"), rs.getString("nombreAl"), rs.getString("apellidos"),
								correo, rs.getString("passw"), rs.getString("matricula"));
						asociarAlumnAsignatura((Alumno) result);
					} else {
						result = new Profesor(rs.getString("dni"), rs.getString("nombreProf"), rs.getString("apellidos"),
								correo, rs.getString("passw"), rs.getString("codEmpleado"), rs.getString("codDepartamento"));
						asociarProfAsignatura((Profesor) result);
					}
				}
				rs = null; //Tentativa de reemplazo a rs.close() que genera problemas
			}
			catch (SQLException e) {} //Ignorar
		}
    	
    	return result;
    }
    
    @Override
	public Hashtable<String, Usuario> readAll() {
		Hashtable<String, Usuario> result = new Hashtable<String, Usuario>();
		Usuario tmp;
		String sql = "SELECT correoETSISI FROM Alumno UNION SELECT correoETSISI FROM Profesor;";
		String cacheCorreo;
		ResultSet rs = conex.ejecutarBusqueda(sql);
		
		if (rs != null) {
			try {
				while (rs.next()) {
					cacheCorreo = rs.getString("correoETSISI");
					tmp = read(cacheCorreo);
					result.put(cacheCorreo, tmp);
				}
				rs = null;
			}
			catch (SQLException e) {} //Ignorar
		}
		return result;
	}
    
    /**
     * Metodo concebido para ser usado con read y readAll. Asocia los Alumnos con las asignaturas que tenga
     * registrado en la BBDD
     * @param al
     */
    private void asociarAlumnAsignatura(Alumno al) throws SQLException {
    	String sql = String.format("SELECT asignatura FROM Cursa WHERE correoAlumno='%s';", al.getCorreo());
    	ResultSet rs = conex.ejecutarBusqueda(sql);
    	if (rs != null) {
			while (rs.next()) {
				al.matricularEnAsig(rs.getString("asignatura"));
			}
			rs = null;
		}
    }
    
    /**
     * Metodo concebido para ser usado con read() y readAll(). Asocia los Profesores con las asignaturas que tenga
     * @param pr
     * @throws SQLException
     */
    private void asociarProfAsignatura(Profesor pr) throws SQLException {
    	String sql = String.format("SELECT asignatura FROM Asociado WHERE correoProf='%s';", pr.getCorreo());
    	ResultSet rs = conex.ejecutarBusqueda(sql);
    	if (rs != null) {
			while (rs.next()) {
				pr.asociarAsig(rs.getString("asignatura"));
			}
			rs = null;
		}
    }
    
    
    @Override
    public void update(String oldId, Usuario newUsr) {
    	//En esta version de la implementacion, la unica actualizacion posible desde la app es la de matricular 
    	//un alumno en una nueva asignatura (un INSERT en la tabla Cursa), partiendo de esa suposicion, se implementa el metodo:
    	
    	Alumno tmp = (Alumno)newUsr;
    	String sql;
    	
    	//Para simplificar al maximo este proceso, se borraran todas las asignaturas que tenga matriculado en la BBDD y se cargan las
    	//nuevas, no es un metodo optimo pero es simple de implementar.
    	sql = String.format("DELETE FROM Cursa WHERE correoAlumno = '%s';", oldId);
    	conex.ejecutarOperacion(sql);
    	
    	Iterator<String> it = tmp.getAsignaturasCursadas().iterator();
    	while (it.hasNext()) {
			sql = String.format("INSERT INTO Cursa(correoAlumno, asignatura) VALUES ('%s', '%s');", tmp.getCorreo(), it.next());
			conex.ejecutarOperacion(sql);
		}
    }
    
    //Delete no sera implementado
	
	/**
	 * Funcion que es usada para determinar si un usuario es alumno (true) o un profesor (false) segun 
	 * el dominio de su direccion de correo ("@alumnos.upm.es" o "@upm.es")
	 * @param correo
	 * @return
	 */
	private boolean esUsuarioAlumno(String correo) {
		return correo.indexOf("@alumnos.upm.es") != -1 ? true : false;
	}
}
