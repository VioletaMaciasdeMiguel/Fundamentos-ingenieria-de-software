package gm22_9.segundaEntregaFIS;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : gm22_9_califyMe
//  @ File Name : PersistenciaAsig.java
//  @ Date : 28/05/2020
//
//



/**
 * Clase Singleton que gestiona la persistencia de las asignaturas
 *
 */
public class PersistenciaAsig implements IPersistenciaAsig {
	
    private static PersistenciaAsig instanciaUnica;
    private IConectorBBDD conex;

    /**
	 * Constructor privado de la clase Singleton
	 */
	private PersistenciaAsig() {
	}
    
	/**
	 * Devuelve instancia unica
	 * @return
	 */
    public static PersistenciaAsig getInstancia() {
    	if (instanciaUnica == null) {
    		instanciaUnica = new PersistenciaAsig();
    	}
    	return instanciaUnica;
    }
    @Override
    public void setConex(IConectorBBDD conex) {
		this.conex = conex;
	}

	@Override
	public void create(Asignatura asig) {
		//Insercion de la asignatura
		String sql = String.format("INSERT INTO Asignatura(nombre, abreviatura, ects) VALUES ('%s', '%s', %d);"
				, asig.getNombreAsignatura(), asig.getAbreviatura(), asig.getEcts());
		conex.ejecutarOperacion(sql);
		
		//Insercion de los prof asociados
		HashSet<String> tmp1 = asig.getProfsAsociados();
		Iterator<String> value = tmp1.iterator();
		while (value.hasNext()) {
            sql = String.format("INSERT INTO Asociado(correoProf, asignatura) VALUES ('%s', '%s');", value.next(), asig.getAbreviatura());
            conex.ejecutarOperacion(sql);
        }
		
		//Insercion de los alumnos matriculados
		HashSet<String> tmp2 = asig.getEsCursadaPor();
		value = tmp2.iterator();
		while (value.hasNext()) {
            sql = String.format("INSERT INTO Cursa(correoAlumno, asignatura) VALUES('%s', '%s');", value.next(), asig.getAbreviatura());
            conex.ejecutarOperacion(sql);
        }
	}

	@Override
	public Asignatura read(String nom) {
		Asignatura result = null;
		
		// Recuperacion de la tabla Asignatura
		String sql = String.format("SELECT nombre, abreviatura, ects FROM Asignatura WHERE abreviatura = '%s';", nom);
		ResultSet rs = conex.ejecutarBusqueda(sql); //Como se esta buscando por la PK, rs o tiene un resultado o es null.
		if (rs != null) {
			try {
				while (rs.next()) {
					result = new Asignatura(rs.getString("nombre"), rs.getString("abreviatura"), rs.getInt("ects"));
					agregarListaPorfAsociados(result);
					agregarListaAlumMatriculados(result);
				}
				rs = null; //Tentativa de reemplazo a rs.close() que genera problemas
			}
			catch (SQLException e) {} //Ignorar
		}
		return result;
	}
	
	@Override
	public Hashtable<String, Asignatura> readAll() {
		Hashtable<String, Asignatura> result = new Hashtable<String, Asignatura>();
		Asignatura tmp;
		String sql = "SELECT nombre, abreviatura, ects FROM Asignatura;";
		ResultSet rs = conex.ejecutarBusqueda(sql);
		if (rs != null) {
			try {
				while (rs.next()) {
					tmp = new Asignatura(rs.getString("nombre"), rs.getString("abreviatura"), rs.getInt("ects"));
					agregarListaPorfAsociados(tmp);
					agregarListaAlumMatriculados(tmp);
					result.put(tmp.getAbreviatura(), tmp);
				}
				rs = null;
			}
			catch (SQLException e) {} //Ignorar
		}
		return result;
	}
	
	/**
	 * Metodo refactorizado que forma para del read y readAll, asocia los profesores
	 * asociados en la asignatura segun aparecen en la BBDD.
	 * @param nuevaAsignatura
	 * @throws SQLException IGNORAR
	 */
	private void agregarListaPorfAsociados(Asignatura nuevaAsignatura) throws SQLException {
		String sql = String.format("SELECT correoProf FROM Asociado WHERE asignatura='%s';", nuevaAsignatura.getAbreviatura());
		ResultSet rs = conex.ejecutarBusqueda(sql);
		
		if (rs != null) {
			while (rs.next()) {
				nuevaAsignatura.asociarProf(rs.getString("correoProf"));
			}
			rs = null;
		}
	}
	
	/**
	 * Metodo refactorizado que forma para del read y readAll, asocia los alumnos
	 * matriculados en la asignatura segun aparecen en la BBDD.
	 * @param nuevaAsignatura
	 * @throws SQLException IGNORAR
	 */
	private void agregarListaAlumMatriculados(Asignatura nuevaAsignatura) throws SQLException {
		String sql = String.format("SELECT correoAlumno FROM Cursa WHERE asignatura='%s';", nuevaAsignatura.getAbreviatura());
		ResultSet rs = conex.ejecutarBusqueda(sql);
		
		if (rs != null) {
			while (rs.next()) {
				nuevaAsignatura.matricularAlumno(rs.getString("correoAlumno"), false);
			}
			rs = null;
		}
	}

	@Override
	public void update(String abrevAsigActualizar, String newAlumnoCorreo) { //Leer el JavaDoc de este metodo en la interfaz, solo se actualizaran los alumnos matriculados.
		conex.ejecutarOperacion(String.format("INSERT INTO Cursa(correoAlumno, asignatura) VALUES ('%s', '%s');", newAlumnoCorreo, abrevAsigActualizar));
	}
	

    //Se ha removido el delete ya que no sera implementado para la entrega
}
